

# 内存加载过程





# 运行时内存结构





# JVM常用指令

## 普通对象内存布局: 

非数组类型的对象头的结构:

![对象头的信息](https://img-blog.csdnimg.cn/20190415101813830.png)

***如果一个对象计算过hashCode就会放到对象头里, 此时该对象将不能进入偏向锁***

1. 对象头, 在Hotsport里面称为markword长度是8字节
2. Classpointer指针: -XX:+UseCompressedClassPointers//开启:4字节,不开启8字节
3. 实例数据: 
   1. 成员变量,引用类型:-XX:+UseCompressedOops//开启:4字节,不开启8字节
4. padding对齐, 对齐是8的倍数,所以所有对象大小都是8的倍数,会被padding填充

## 数组对象内存布局: 



## 指令

-XX:+UseCompressedClassPointers//开启对象头ClassPointer压缩,开启:4字节,不开启8字节

-XX:+UseCompressedOops//开启





# GC和调优*

### 如何标记对象是否是垃圾(垃圾如何定位)?

1. 引用计数
2. root searching(根可达算法)

### 如何清理垃圾的(垃圾如何回收)?

1. #### Mark-Sweep(标记清除)

   * 说明: 把垃圾标出来, 然后清掉
   * 执行次数: 两遍扫描, 第一遍找到有用对象象, 第二遍没用的清理掉
   * 优缺点: 位置不连续, 产生碎片, 执行效率偏低
   * 适用情况: 适用于存货对象较多的情况

2. #### Copy(复制)

   * 说明: 将内存分为两份, 将有用的对象复制到另一份内存中,再清掉这一整块内存
   * 执行次数: 1次
   * 优缺点: 空间浪费, 没有碎片, 效率高
   * 适用情况: 存货对象较少的情况

3. #### Mark-Compact(标记压缩)

   * 说明: 将所有的东西整理的过程,清理的过程同事压缩到头上去
   * 执行次数: 一遍找出有用对象 ,二遍进行移动
   * 优缺点: 效率低很多, 不会产生碎片
   * 适用情况: 存货对象较少的情况

## 堆内存逻辑分区

新生代大量死去, 少量存活, 采用copy

老年代存活率高, 回收较少, 采用MC或MS

新生代
