

# 多线程与高并发

## 基础介绍

线程指的是程序执行路径, 多线程就是多个执行路径, CPU在多个路径里来回切换.

```java
public class Main {
    public static void main(String[] args) {
        Runnable1 r = new Runnable1();
        Thread t = new Thread(r);
        t.start();
        for (int i = 0; i < 100; i++){
            System.out.printf("嘿嘿嘿");
        }
    }
}
class Runnable1 implements Runnable//还有继承Thread类的方法,一般使用接口方式实现, 方便灵活
{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++){
            System.out.printf("啦啦啦");
        }
    }
}
输出: 
嘿嘿嘿
啦啦啦
嘿嘿嘿
```

**线程的状态: new , 就绪状态, 运行状态, 阻塞状态, 死亡状态**

Thread的一些重要方法: 

```
start()#是线程进入就绪状态,以供CPU调用
run()#CPU调用方法执行任务
setName()#设置线程名
setPriority()#更改线程的优先级。
setDaemon()#将该线程标记为守护线程或用户线程。
join()#t1线程中执行语句t2.join();表示从t1切换到t2线程, t2线程执行结束后才执行t1线程
interrupt()#中断线程。
isAlive()//测试线程是否处于活动状态
静态
yield()#暂停当前正在执行的线程对象，并执行其他线程
sleep()#在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。
holdsLock()#当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。
currentThread()#返回对当前正在执行的线程对象的引用。
dumpStack()#将当前线程的堆栈跟踪打印至标准错误流。
```

## 线程同步

#### synchronized用法:

```java
#执行该方法时, 查看当前对象是否被锁定, 被锁定则其他线程等待所释放后, 当前前程获得该锁后执行
public synchronized void add (String name){
}
#和上面用法是一样的意思
public void add (String name){
  synchronized (this){...}
}
```

##### 优化:

1. 该细粒度的细粒度 , 该粗粒度的粗粒度
2. 锁对象的时候不可以修改锁的对象, 会导致同步不正常 
3. 不可使用String Integer 作为锁对象

##### 注意: 

1. synchronized是可重入的, 也就是说, synchronized m1()方法内可以调用 synchronized m2()方法的, 不会产生死锁
2. 修改同步, 获取不同步的话会产生脏读现象, 视需求来看获取需不需要将获取也改为同步(这样效率将变慢)
3. synchronized中的代码如果发生了异常, 锁将解除, 其他线程将进入, 需要做好异常后的处理
4. 如果锁的是static方法, 那么synchronized锁的是T.class对象(类对象)

##### 被锁的对象:

1. 对象头里的MarkWord中两位记录着该对象被锁情况

#### volatile

作用:

1. 保证线程的可见性(两个线程内的同一成员变量值会不同, 可以保证他们相同) 
2. 禁止指令重排序(CPU) (单例模式中的Double Check Lock)

## 锁升级过程

### 1.无锁

### 2.偏向锁

对象头

如果线程争用升级为轻量级锁(自旋锁)

### 3. 轻量级锁

执行时间短(指加锁代码), 线程数少: 使用自旋锁.

十次自旋后升级为重量级锁

### 4. 重量级锁-OS

需要去请求OS资源的锁

执行时间长(指加锁代码), 线程数多: 使用重量级锁.

## CAS(自旋锁)

什么是CAS: 

CAS指令是一个CPU`层级的原子性操作指令`

例子:

```java
import java.util.concurrent.atomic.AtomicInteger

AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();//当多个线程执行这条语句时, 是线程同步的. 用的是CAS操作
```

原理: 

















## 生产者和消费者问题

```java
package Thread;


public class ProducerConsumer {
    public static void main(String[] args) {
        SyncStack ss = new SyncStack();
        Producer p = new Producer(ss);
        Consumer s = new Consumer(ss);

        new Thread(p).start();
        new Thread(s).start();
    }
}
class WoTou {
    int id;
    WoTou(int id){
        this.id = id;
    }
    public String toString(){
        return "WoTou : " + id;
    }
}
class SyncStack{
    int index = 0;
    WoTou[] arrWT = new WoTou[6];
    public synchronized void push(WoTou wt){
        while(index == arrWT.length){
            try {
                this.wait();//当前执行的线程wait(), 且必须synchronized
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        this.notify();//叫醒另一个线程,. 好像放在synchronized里面任意一行都行...不知道
        arrWT[index] = wt;
        index++;
    }
    public synchronized WoTou pop(){
        while(index == 0){
            try {
                this.wait();//当前执行的线程wait(), 且必须synchronized
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        this.notify();//叫醒一个
        index--;
        return arrWT[index];
    }
}
class Producer implements Runnable {
    SyncStack ss = null;
    Producer (SyncStack ss){
        this.ss = ss;
    }
    public void run (){
        for(int i = 0; i < 20; i++){
            WoTou wt = new WoTou(i);
            ss.push(wt);
            System.out.println("生产了" + wt);
//            try {
//                Thread.sleep(1000);
//            }catch (InterruptedException e){
//                e.printStackTrace();
//            }
        }
    }
}
class Consumer implements Runnable {
    SyncStack ss = null;
    Consumer (SyncStack ss){
        this.ss = ss;
    }
    public void run (){
        for(int i = 0; i < 20; i++){
            WoTou wt = new WoTou(i);
            ss.pop();
            System.out.println("消费了" + wt);
//            try {
//                Thread.sleep(1000);
//            }catch (InterruptedException e){
//                e.printStackTrace();
//            }
        }
    }
}
```

