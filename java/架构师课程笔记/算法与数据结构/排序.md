## 排序

#### 冒泡

```java
public void bubbleSort (int[] arr){
    if(arr == null || arr.length < 2)
        return;
    for(int i = 0; i < arr.length -1; i++){
        for(int j = 1; j < arr.length - i; j++){
            if(arr[j] < arr[j-1]){
                arr[j-1] = arr[j-1] ^ arr[j];  
                arr[j]   = arr[j-1] ^ arr[j];
                arr[j-1] = arr[j-1] ^ arr[j];
            }
        }
    }
}
```

#### 选择

```java
public void selectSort(int [] arr) {
    for(int i = 0; i < arr.length - 1 ; i ++){
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++){
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```

#### 插入

```java
    public void insertionSort(int[] arr){
        for (int i = 1; i < arr.length; i++){
            for (int j = i - 1; j >= 0 && arr[j] > arr[j+1]; j--){
                arr[j]   = arr[j] ^ arr[j+1];
                arr[j+1] = arr[j] ^ arr[j+1];
                arr[j]   = arr[j] ^ arr[j+1];
            }
        }
    }
```

#### 二分查找

1. 在一个有序数组中, 找某个数是否存在
2. 在一个有序数组中,找>=某个数最左侧的位置
3. 在一个有序数组中,找<=某个数最右侧的位置
4. 在一个无序数组中,局部最小值问题

```java
public static int BinarySearch(int[] arr, int num){
  	int L = 0;
  	int R = arr.length - 1;
  	int mid = 0;
  	while(L < R){
      	mid = L + ((R - L) >> 1);//mid = (R + L) / 2
      	if(arr[mid] == num){
          return true;
        }else if(arr[mid] > num){
          R = mid - 1;
        }else{
          L = mid + 1;
        }
    }
  	return arr[L] == num;
}
```

#### 归并排序

```java
  public static void mergeSort2(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int N = arr.length;
		int mergeSize = 1;// 当前有序的，左组长度
		while (mergeSize < N) { // log N
			int L = 0;
			// 0.... 
			while (L < N) {
				// L...M  左组（mergeSize）
				int M = L + mergeSize - 1;
				if (M >= N) {
					break;
				}
				//  L...M   M+1...R(mergeSize)
				int R = Math.min(M + mergeSize, N - 1);
				merge(arr, L, M, R);
				L = R + 1;
			}
			if (mergeSize > N / 2) {
				break;
			}
			mergeSize <<= 1;
		}
	}

	public static void merge(int[] arr, int L, int M, int R) {
		int[] help = new int[R - L + 1];
		int i = 0;
		int p1 = L;
		int p2 = M + 1;
		while (p1 <= M && p2 <= R) {
			help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
		}
		// 要么p1越界了，要么p2越界了
		while (p1 <= M) {
			help[i++] = arr[p1++];
		}
		while (p2 <= R) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[L + i] = help[i];
		}
	}
```

#### 随机快排

```java
	public static void process3(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
		int[] equalArea = netherlandsFlag(arr, L, R);
		process3(arr, L, equalArea[0] - 1);
		process3(arr, equalArea[1] + 1, R);
	}

	// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值
	//  <arr[R]  ==arr[R]  > arr[R]
	public static int[] netherlandsFlag(int[] arr, int L, int R) {
		if (L > R) {
			return new int[] { -1, -1 };
		}
		if (L == R) {
			return new int[] { L, R };
		}
		int less = L - 1; // < 区 右边界
		int more = R;     // > 区 左边界
		int index = L;
		while (index < more) {
			if (arr[index] == arr[R]) {
				index++;
			} else if (arr[index] < arr[R]) {
				swap(arr, index++, ++less);
			} else { // >
				swap(arr, index, --more);
			}
		}
		swap(arr, more, R);
		return new int[] { less + 1, more };
	}
```



#### 堆排序

```java

```



### 桶排序

桶排序是一种思想, 不靠比较来排序, 但是对桶(数组的大小--比如比较人的年龄, 最多不会超过200, )的范围有要求, 

基数排序, 计数排序

#### 计数排序

桶排序的一种实现

```java
public static void countSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
        max = Math.max(max, arr[i]);
    }
    int[] bucket = new int[max + 1];
    for (int i = 0; i < arr.length; i++) {
        bucket[arr[i]]++;
    }
    int i = 0;
    for (int j = 0; j < bucket.length; j++) {
        while (bucket[j]-- > 0) {
            arr[i++] = j;
        }
    }
}
```

#### 基数排序

桶排序的一种实现

```java
public static void radixSort(int[] arr, int L, int R, int digit) {
    final int radix = 10;
    int i = 0, j = 0;
    // 有多少个数准备多少个辅助空间
    int[] help = new int[R - L + 1];
    for (int d = 1; d <= digit; d++) { // 有多少位就进出几次
        // 10个空间
        // count[0] 当前位(d位)是0的数字有多少个
        // count[1] 当前位(d位)是(0和1)的数字有多少个
        // count[2] 当前位(d位)是(0、1和2)的数字有多少个
        // count[i] 当前位(d位)是(0~i)的数字有多少个
        int[] count = new int[radix]; // count[0..9]
        for (i = L; i <= R; i++) {
            // 103  1   3
            // 209  1   9
            j = getDigit(arr[i], d);
            count[j]++;
        }
        for (i = 1; i < radix; i++) {
            count[i] = count[i] + count[i - 1];
        }
        for (i = R; i >= L; i--) {
            j = getDigit(arr[i], d);
            help[count[j] - 1] = arr[i];
            count[j]--;
        }
        for (i = L, j = 0; i <= R; i++, j++) {
            arr[i] = help[j];
        }
    }
}
```

# 堆

**堆**（英语：Heap）是[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中的一种特别的树状[数据结构](https://zh.wikipedia.org/wiki/数据结构)。若是满足以下特性，即可称为堆：“给定堆中任意[节点](https://zh.wikipedia.org/wiki/節點)P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值”。若母节点的值恒**小于等于**子节点的值，此堆称为**最小堆**（min heap）；反之，若母节点的值恒**大于等于**子节点的值，此堆称为**最大堆**（max heap）。在堆中最顶端的那一个节点，称作**根节点**（root node），根节点本身没有**母节点**（parent node）。

```java
//从index位置, 往上看, 上浮
private void heapInsert(int[] arr, int index) {
  while (arr[index] > arr[(index - 1) / 2]) {
    swap(arr, index, (index - 1) / 2);
    index = (index - 1) / 2;
  }
}
```

```java
// 从index位置，往下看，不断的下沉
private void heapify(int[] arr, int index, int heapSize) {
  int left = index * 2 + 1;
  while (left < heapSize) {
    int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
    largest = arr[largest] > arr[index] ? largest : index;
    if (largest == index) {
      break;
    }
    swap(arr, largest, index);
    index = largest;
    left = index * 2 + 1;
  }
}
```

